---
title: ml
mathjax: true
abbrlink: d58e2a66
date: 2024-02-24 17:20:13
tags: 知识
---


**`2023`年`11`月`8`日学习`ML`，共耗时：`6`小时**
**学习资料：[machine learning](http://www.ai-start.com/ml2014/html/)**

> 正视自己现在的态度：想做建大的事情并且快速获得可以擦后果别人的成果，想什么呢？  
> 只有掌握技术，才能去享受技术，就像只有会游泳才能享受游泳的乐趣，如果中途半途而废了，那么之前做的一切都会没有价值
> 既然选择了走这么一条艰难地路，顶一个宏大的目标，那就坚持下去
## 监督学习和无监督学习    
监督学习：回归问题或者对于已知种类的分类判断问题    
无监督学习：对于未知种类的自动判断种类(聚类算法)    

## 特征

特征相当于变量，不同问题的特征值是不一样的，机器学习是对于某一种具有相同特征值的问题进行处理的方法  
梯度下降对于参数求导数，来判断参数往哪个方向调整会产生预期结果

## 线性回归

最简单的对于一元自变量：    
多个数据来拟合一条直线，来进行预测或者分类，对于离散问题也可以使用线性回归：    
$$y = \beta_0 + \beta_1 x_i$$  
残差：  
$$e = y - \widehat{y}$$   
损失函数：残差平方和    
可以使用最小二乘法来求解拟合直线参数 $\beta_0$ 和 $\beta_1$ :   
对于残差平方和$Q,\beta_0,\beta_1$，图像是三维凸函数，所以极小值是对$\beta_0.\beta_1$求偏导为0的点   
$$\frac{\partial Q}{\partial\beta_0} = 2\sum_{1}^n(y_i - \widehat{\beta_0} - \widehat{\beta_1}x_i) = 0$$   
$$\frac{\partial Q}{\partial\beta_1} = 2\sum_{1}^n(y_i - \widehat{\beta_0} - \widehat{\beta_1}x_i)x_i = 0$$   
（多维的话就对多个进行偏导求解）    
可以用来求解局部最小值或者全局最小值    
拟合的时候不一定使用线性回归，也可能使用其他函数的回归，看对于数据点那个比较适用  

## 梯度下降

思想是：    
对于一个预测问题或者分类问题需要去数学建模来构造预测函数，于是建模有函数 $h(\Theta^TX)$ 作为预测假设    
接下来需要改良假设的拟合效果，所以要通过学习来更新矩阵 $\Theta$
评判标准：代价函数 $$J(\theta_1,\theta_2,\dots,\theta_n)$$ 代表了当前选取的参数的建模误差     
为了要代价函数最小，所以根据代价函数的值来更新 $$\theta_i$$
于是有对 $J$ 对 $\theta_i$ 求偏导的方法来更新 $\theta_i$ 值  

批量梯度下降(因为每一步用到了所有的数据点)：      
选取随机的参数组合 $$(\theta_0,\theta_1\dots\theta_n)$$,来对每个参数组合求解局部最小值，来寻找全局最小值  
$$\theta_j=\theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta_0, \theta-1)$$    
其中 $\alpha$ 称为学习率，也看作步长，$\theta_0和\theta_1会及时更新$

(为什么要使用梯度下降：不是所有函数都能求偏导，函数也可能是黑盒，并且偏导等于0的点不一定是极值点) 

### 多维梯度下降
判断函数： $$h_\theta(x) = \theta^T X$$   
梯度下降函数： $$\theta_j = \theta_j - \alpha\frac{1}{m}\sum_{i=1}^m((h/-\theta(x^{(i)}) - y^{(i)})x_j^{(i)})$$   
注意多项式不一定是线性的，有可能是高次的，但是参数是线性的，不影响对于参数的梯度下降    
选取正确的模型方程很重要

### 梯度下降优化

统一特征尺度，为了准确度，需要将特征尺度统一到(0,1)的区间：  
$$ x_n = \frac{x_n - \mu_n}{s_n} $$   
其中 $\mu_n,s_n$为平均值和标准差

### 正规方程
对于**线性回归问题**
当特征值少的时候，可以直接用正规方程的方法来得到最合适的参数矩阵：  
$$\theta = (X^TX)^{-1}X^Ty$$    
直接可以求得最小代价函数的参数矩阵  
对于小样本数但是需要多个参数的时候，使用正则化来减少特征值个数

## 逻辑回归

线性回归拟合+预测值用sigmod函数来进行分类 

决策边界：  
来判断分类种类的函数，所以对于比较复杂的分类种类，通常需要选取复杂的决策边界函数 $\theta^TX$ 才行   

对于决策边界$w_1 x_1+w_2 x_2 + b = 0$，有决策函数$g(w_1 x_1+w_2 x_2 + b)$   
即$w_1 x_1+w_2 x_2 + b > 0$为类别$Y = 1$，小于0则是另一类，用来表示$P(Y = 1 \mid x)$  
其中x表示x向量$(x_1 , x_2)$，用$W^T$表示向量$(w_1, w_2)$,   
定义对数几率 $\ln{\frac{y}{1-y}} = w_T x + b$ 与x成线性关系，其中y是为1的概率   
所以逻辑回归要先拟合出决策边界，在将这个边界和分类概率建立联系  
逻辑回归也需要使用特征缩放  

### 代价函数    
对于逻辑回归，假设函数给出的是离散值，所以需要sigmod函数来把连续值的输出离散化：
$$h_\theta(x) = g(\Theta^TX)$$
$$g(z) = \frac{1}{1+e^{-z}}$$

如果按原来的方法构建代价函数的话，会产生一个非凸函数，会陷入局部最小值里    
所以构建误差函数：  
$$Cost(h_\theta(x),y) = -y \times \ln(h_\theta(x)) - (1-y)\times\ln(1-h_\theta(x))$$
然后求和求偏导得到代价函数 $J(\theta)$

### 更优化的学习方法
共轭梯度法 BFGS (变尺度法) 和L-BFGS (限制变尺度法)  
有智能的内部循环（线性搜索）来自动选取学习率    

### 一对多分类

对于有多个种类的分类方法，计算每一个类别的概率函数  
将其中一个类看做正向类，其余看做负向类  
有取 $\max(h_\theta^{(i)}(x))$

### 正则化
为了防止过拟合的问题，使用正则化来扩大某个参数的影响，以减小这个参数的值，做到减小这个参数影响力的效果  
正则化线性回归的代价函数为：
$$J(\theta) = \frac{1}{2m}\sum_{i=1}^{m}[((h_\theta(x^i)-y^i)^2 + \lambda\sum_{j=1}^{n}\theta_j^2)]$$


## 神经网络

当特征变量多了以后，不同次方的组合数太多了，比如对图片的像素特征处理，所以要用到神经网络
神经网络通过多层权重(参数)矩阵能进行十分庞大的种类变换，而且变换是传播扩散的，也可以将特征变量通过权重矩阵扩展到多维，来产生任意维的输出    
g(x)表示sigmod函数

每一次层的参数矩阵对上一层输出的特征值或者中间值进行处理，来生成下一层的输入

可以有多个结果的输出值，即为多分类问题，也可以改变偏差单位(bias unit)来进行逻辑运算操作，从左到右的网络称之为向前传播算法，多分类问题的输出变量是一个向量   

$s_l$代表l层，$\theta_l$代表l层到l+1层的参数矩阵，其大小为 $s_{l+1} \times s_l + 1$，所以神经网络的代价函数是多余每一个分类的代价函数的和和正则化每一个参数的平方和 

### 反向传播梯度优化

为了计算对于某一层的某一个参数的对于代价函数 $J(\theta)$的偏导数，需要用到反向传播的方法来求    
首先由正向传播计算得到神经网络的预测值，然后从后往前有：
$$\sigma^{(l)} = (\Theta^{(l)})^T\sigma^{(l+1)}*g'(z^{(l)})$$
$$\frac{\partial}{\partial\Theta_{ij}^{(l)}} J(Ttheta) = \alpha_j^{(l)}\sigma_i^{(l+1)}$$

表示第l层的第j个激活单元收到了第l层的第i行参数的影响而产生的误差单元    
如果特征值是一个特征矩阵，那么会产生一个误差矩阵 $\triangle_{ij}^l$

### 神经网络的训练步骤

- 参数随机初始化
- 正向传播计算 $h_\theta(x)$
- 计算代价函数
- 反向传播计算偏导
- 数值检验校验偏导
- 优化算法最小化代价函数

## 应用

基本的减小误差的思路：
- 使用更多样本
- 减少特征数量
- 增加特征数量
- 增加多项式复杂度
- 减少正则化程度
- 增加正则化程度

区部分数据集作为训练集、部分数据集作为测试集

进一步，可以使用交叉验证(cross validation error)来选取一部分数据作为交叉验证集，不同的数据集组合会对同一个模型产生不同的学习器(注意区分概念)，交叉验证集用于对不同学习器进行拟合度校验，有不同的算法和参数确定不同的模型，再在每个模型中通过交叉验证得到不同的学习器，对于k折交叉验证得到的学习器拟和的准确率取平均作为打分，来找到最佳的模型

数据拟合不好无非两种情况：过拟合和欠拟合

使用交叉验证时，随着多项式次数的增长，会由欠拟合到过拟合，错误率是下凸函数，所以要判断是偏差/欠拟合还是方差/过拟合

训练集误差和交叉验证集误差近似时：偏差/欠拟合 交叉验证集误差远大于训练集误差时：方差/过拟合

对于正则化参数的选择 $\lambda$ 也是，通常是使用 0-10之间的呈现2倍关系的值

训练集误差随着 $lambda$ 值的增大而增大，交叉验证集误差随着 $\lambda$值的增大而先增大后减小，由过拟合到欠拟合

### 学习曲线
当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据

将训练集误差和交叉测试集误差作为训练样本规模的函数

区分欠拟合/过拟合：     
对于欠拟合，增加训练集规模的时候训练误差和交叉测试集误差趋于稳定，不受影响      
当过拟合的时候，交叉测试集误差明显大于训练集误差，增加训练集规模效果显著    

### 误差检验

思想：不要想着一开始就得到完美的模型，是需要用方法来验证以及用证据来指导进一步的优化和方向的，有时候不能仅凭直觉来解决问题  

- 简单算法，使用交叉验证集测试
- 绘制学习曲线来决定进一步的选择
- 误差检验，来看是否有什么系统化的趋势
  
### 数值误差度量

查准率(P)：判断正例中的真正例的比例     
查全率(R)：真正例中判断出的比例     
有TP\FN\FP\TN
$$P = \frac{TP}{TP+FP}$$ 
$$R = \frac{TP}{TP+FN}$$
一般两者矛盾，所以使用F1方法度量：  
$$\frac{1}{F_1} = \frac{1}{2}(\frac{1}{P} + \frac{1}{R})$$
加权调和平均：  $F_\beta$
$$\frac{1}{F_\beta} = \frac{1}{1+\beta^2}(\frac{1}{P} + \frac{\beta^2}{R})$$
- $\beta = 1$即为 $F_1$
- $\beta < 1$查准更多
- $\beta > 1$查全更多

### 数据的地位

> 取得成功的人不是拥有最好算法的人，而是拥有最多数据的人

所谓好的算法是数据集不足的时候也能给出低方差低偏差的预测结果

## SVM



